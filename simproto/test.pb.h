// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#ifndef PROTOBUF_test_2eproto__INCLUDED
#define PROTOBUF_test_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace simproto {
namespace test {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_test_2eproto();
void protobuf_AssignDesc_test_2eproto();
void protobuf_ShutdownFile_test_2eproto();

class Request;
class Response;
class Response_ReturnCode;
class Response_ReturnBody;

enum Response_BodyType {
  Response_BodyType_JSON = 0,
  Response_BodyType_TEXT = 1,
  Response_BodyType_XML = 2
};
bool Response_BodyType_IsValid(int value);
const Response_BodyType Response_BodyType_BodyType_MIN = Response_BodyType_JSON;
const Response_BodyType Response_BodyType_BodyType_MAX = Response_BodyType_XML;
const int Response_BodyType_BodyType_ARRAYSIZE = Response_BodyType_BodyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_BodyType_descriptor();
inline const ::std::string& Response_BodyType_Name(Response_BodyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_BodyType_descriptor(), value);
}
inline bool Response_BodyType_Parse(
    const ::std::string& name, Response_BodyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_BodyType>(
    Response_BodyType_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ver = 1 [default = "1.0"];
  inline bool has_ver() const;
  inline void clear_ver();
  static const int kVerFieldNumber = 1;
  inline const ::std::string& ver() const;
  inline void set_ver(const ::std::string& value);
  inline void set_ver(const char* value);
  inline void set_ver(const char* value, size_t size);
  inline ::std::string* mutable_ver();
  inline ::std::string* release_ver();
  inline void set_allocated_ver(::std::string* ver);

  // required string cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // repeated string args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // @@protoc_insertion_point(class_scope:simproto.test.Request)
 private:
  inline void set_has_ver();
  inline void clear_has_ver();
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ver_;
  static ::std::string* _default_ver_;
  ::std::string* cmd_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response_ReturnCode : public ::google::protobuf::Message {
 public:
  Response_ReturnCode();
  virtual ~Response_ReturnCode();

  Response_ReturnCode(const Response_ReturnCode& from);

  inline Response_ReturnCode& operator=(const Response_ReturnCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ReturnCode& default_instance();

  void Swap(Response_ReturnCode* other);

  // implements Message ----------------------------------------------

  Response_ReturnCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ReturnCode& from);
  void MergeFrom(const Response_ReturnCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 err_no = 1 [default = 0];
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // required string err_msg = 2 [default = "OK"];
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 2;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // @@protoc_insertion_point(class_scope:simproto.test.Response.ReturnCode)
 private:
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* err_msg_;
  static ::std::string* _default_err_msg_;
  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static Response_ReturnCode* default_instance_;
};
// -------------------------------------------------------------------

class Response_ReturnBody : public ::google::protobuf::Message {
 public:
  Response_ReturnBody();
  virtual ~Response_ReturnBody();

  Response_ReturnBody(const Response_ReturnBody& from);

  inline Response_ReturnBody& operator=(const Response_ReturnBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ReturnBody& default_instance();

  void Swap(Response_ReturnBody* other);

  // implements Message ----------------------------------------------

  Response_ReturnBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ReturnBody& from);
  void MergeFrom(const Response_ReturnBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .simproto.test.Response.BodyType type = 1 [default = JSON];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::simproto::test::Response_BodyType type() const;
  inline void set_type(::simproto::test::Response_BodyType value);

  // required string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:simproto.test.Response.ReturnBody)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static Response_ReturnBody* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_ReturnCode ReturnCode;
  typedef Response_ReturnBody ReturnBody;

  typedef Response_BodyType BodyType;
  static const BodyType JSON = Response_BodyType_JSON;
  static const BodyType TEXT = Response_BodyType_TEXT;
  static const BodyType XML = Response_BodyType_XML;
  static inline bool BodyType_IsValid(int value) {
    return Response_BodyType_IsValid(value);
  }
  static const BodyType BodyType_MIN =
    Response_BodyType_BodyType_MIN;
  static const BodyType BodyType_MAX =
    Response_BodyType_BodyType_MAX;
  static const int BodyType_ARRAYSIZE =
    Response_BodyType_BodyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BodyType_descriptor() {
    return Response_BodyType_descriptor();
  }
  static inline const ::std::string& BodyType_Name(BodyType value) {
    return Response_BodyType_Name(value);
  }
  static inline bool BodyType_Parse(const ::std::string& name,
      BodyType* value) {
    return Response_BodyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string ver = 1 [default = "1.0"];
  inline bool has_ver() const;
  inline void clear_ver();
  static const int kVerFieldNumber = 1;
  inline const ::std::string& ver() const;
  inline void set_ver(const ::std::string& value);
  inline void set_ver(const char* value);
  inline void set_ver(const char* value, size_t size);
  inline ::std::string* mutable_ver();
  inline ::std::string* release_ver();
  inline void set_allocated_ver(::std::string* ver);

  // required .simproto.test.Response.ReturnCode code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline const ::simproto::test::Response_ReturnCode& code() const;
  inline ::simproto::test::Response_ReturnCode* mutable_code();
  inline ::simproto::test::Response_ReturnCode* release_code();
  inline void set_allocated_code(::simproto::test::Response_ReturnCode* code);

  // repeated .simproto.test.Response.ReturnBody body = 3;
  inline int body_size() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 3;
  inline const ::simproto::test::Response_ReturnBody& body(int index) const;
  inline ::simproto::test::Response_ReturnBody* mutable_body(int index);
  inline ::simproto::test::Response_ReturnBody* add_body();
  inline const ::google::protobuf::RepeatedPtrField< ::simproto::test::Response_ReturnBody >&
      body() const;
  inline ::google::protobuf::RepeatedPtrField< ::simproto::test::Response_ReturnBody >*
      mutable_body();

  // @@protoc_insertion_point(class_scope:simproto.test.Response)
 private:
  inline void set_has_ver();
  inline void clear_has_ver();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ver_;
  static ::std::string* _default_ver_;
  ::simproto::test::Response_ReturnCode* code_;
  ::google::protobuf::RepeatedPtrField< ::simproto::test::Response_ReturnBody > body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// Request

// required string ver = 1 [default = "1.0"];
inline bool Request::has_ver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_ver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_ver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_ver() {
  if (ver_ != _default_ver_) {
    ver_->assign(*_default_ver_);
  }
  clear_has_ver();
}
inline const ::std::string& Request::ver() const {
  return *ver_;
}
inline void Request::set_ver(const ::std::string& value) {
  set_has_ver();
  if (ver_ == _default_ver_) {
    ver_ = new ::std::string;
  }
  ver_->assign(value);
}
inline void Request::set_ver(const char* value) {
  set_has_ver();
  if (ver_ == _default_ver_) {
    ver_ = new ::std::string;
  }
  ver_->assign(value);
}
inline void Request::set_ver(const char* value, size_t size) {
  set_has_ver();
  if (ver_ == _default_ver_) {
    ver_ = new ::std::string;
  }
  ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_ver() {
  set_has_ver();
  if (ver_ == _default_ver_) {
    ver_ = new ::std::string(*_default_ver_);
  }
  return ver_;
}
inline ::std::string* Request::release_ver() {
  clear_has_ver();
  if (ver_ == _default_ver_) {
    return NULL;
  } else {
    ::std::string* temp = ver_;
    ver_ = const_cast< ::std::string*>(_default_ver_);
    return temp;
  }
}
inline void Request::set_allocated_ver(::std::string* ver) {
  if (ver_ != _default_ver_) {
    delete ver_;
  }
  if (ver) {
    set_has_ver();
    ver_ = ver;
  } else {
    clear_has_ver();
    ver_ = const_cast< ::std::string*>(_default_ver_);
  }
}

// required string cmd = 2;
inline bool Request::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& Request::cmd() const {
  return *cmd_;
}
inline void Request::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void Request::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void Request::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* Request::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string args = 3;
inline int Request::args_size() const {
  return args_.size();
}
inline void Request::clear_args() {
  args_.Clear();
}
inline const ::std::string& Request::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* Request::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void Request::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void Request::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void Request::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::add_args() {
  return args_.Add();
}
inline void Request::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void Request::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void Request::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Request::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Request::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// Response_ReturnCode

// required int32 err_no = 1 [default = 0];
inline bool Response_ReturnCode::has_err_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ReturnCode::set_has_err_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ReturnCode::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ReturnCode::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 Response_ReturnCode::err_no() const {
  return err_no_;
}
inline void Response_ReturnCode::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// required string err_msg = 2 [default = "OK"];
inline bool Response_ReturnCode::has_err_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ReturnCode::set_has_err_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ReturnCode::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ReturnCode::clear_err_msg() {
  if (err_msg_ != _default_err_msg_) {
    err_msg_->assign(*_default_err_msg_);
  }
  clear_has_err_msg();
}
inline const ::std::string& Response_ReturnCode::err_msg() const {
  return *err_msg_;
}
inline void Response_ReturnCode::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == _default_err_msg_) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void Response_ReturnCode::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == _default_err_msg_) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void Response_ReturnCode::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == _default_err_msg_) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_ReturnCode::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == _default_err_msg_) {
    err_msg_ = new ::std::string(*_default_err_msg_);
  }
  return err_msg_;
}
inline ::std::string* Response_ReturnCode::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == _default_err_msg_) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(_default_err_msg_);
    return temp;
  }
}
inline void Response_ReturnCode::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != _default_err_msg_) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(_default_err_msg_);
  }
}

// -------------------------------------------------------------------

// Response_ReturnBody

// required .simproto.test.Response.BodyType type = 1 [default = JSON];
inline bool Response_ReturnBody::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ReturnBody::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ReturnBody::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ReturnBody::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::simproto::test::Response_BodyType Response_ReturnBody::type() const {
  return static_cast< ::simproto::test::Response_BodyType >(type_);
}
inline void Response_ReturnBody::set_type(::simproto::test::Response_BodyType value) {
  assert(::simproto::test::Response_BodyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string content = 2;
inline bool Response_ReturnBody::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ReturnBody::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ReturnBody::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ReturnBody::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Response_ReturnBody::content() const {
  return *content_;
}
inline void Response_ReturnBody::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Response_ReturnBody::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Response_ReturnBody::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_ReturnBody::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* Response_ReturnBody::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_ReturnBody::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response

// required string ver = 1 [default = "1.0"];
inline bool Response::has_ver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_ver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_ver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_ver() {
  if (ver_ != _default_ver_) {
    ver_->assign(*_default_ver_);
  }
  clear_has_ver();
}
inline const ::std::string& Response::ver() const {
  return *ver_;
}
inline void Response::set_ver(const ::std::string& value) {
  set_has_ver();
  if (ver_ == _default_ver_) {
    ver_ = new ::std::string;
  }
  ver_->assign(value);
}
inline void Response::set_ver(const char* value) {
  set_has_ver();
  if (ver_ == _default_ver_) {
    ver_ = new ::std::string;
  }
  ver_->assign(value);
}
inline void Response::set_ver(const char* value, size_t size) {
  set_has_ver();
  if (ver_ == _default_ver_) {
    ver_ = new ::std::string;
  }
  ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_ver() {
  set_has_ver();
  if (ver_ == _default_ver_) {
    ver_ = new ::std::string(*_default_ver_);
  }
  return ver_;
}
inline ::std::string* Response::release_ver() {
  clear_has_ver();
  if (ver_ == _default_ver_) {
    return NULL;
  } else {
    ::std::string* temp = ver_;
    ver_ = const_cast< ::std::string*>(_default_ver_);
    return temp;
  }
}
inline void Response::set_allocated_ver(::std::string* ver) {
  if (ver_ != _default_ver_) {
    delete ver_;
  }
  if (ver) {
    set_has_ver();
    ver_ = ver;
  } else {
    clear_has_ver();
    ver_ = const_cast< ::std::string*>(_default_ver_);
  }
}

// required .simproto.test.Response.ReturnCode code = 2;
inline bool Response::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_code() {
  if (code_ != NULL) code_->::simproto::test::Response_ReturnCode::Clear();
  clear_has_code();
}
inline const ::simproto::test::Response_ReturnCode& Response::code() const {
  return code_ != NULL ? *code_ : *default_instance_->code_;
}
inline ::simproto::test::Response_ReturnCode* Response::mutable_code() {
  set_has_code();
  if (code_ == NULL) code_ = new ::simproto::test::Response_ReturnCode;
  return code_;
}
inline ::simproto::test::Response_ReturnCode* Response::release_code() {
  clear_has_code();
  ::simproto::test::Response_ReturnCode* temp = code_;
  code_ = NULL;
  return temp;
}
inline void Response::set_allocated_code(::simproto::test::Response_ReturnCode* code) {
  delete code_;
  code_ = code;
  if (code) {
    set_has_code();
  } else {
    clear_has_code();
  }
}

// repeated .simproto.test.Response.ReturnBody body = 3;
inline int Response::body_size() const {
  return body_.size();
}
inline void Response::clear_body() {
  body_.Clear();
}
inline const ::simproto::test::Response_ReturnBody& Response::body(int index) const {
  return body_.Get(index);
}
inline ::simproto::test::Response_ReturnBody* Response::mutable_body(int index) {
  return body_.Mutable(index);
}
inline ::simproto::test::Response_ReturnBody* Response::add_body() {
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::simproto::test::Response_ReturnBody >&
Response::body() const {
  return body_;
}
inline ::google::protobuf::RepeatedPtrField< ::simproto::test::Response_ReturnBody >*
Response::mutable_body() {
  return &body_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace test
}  // namespace simproto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::simproto::test::Response_BodyType>() {
  return ::simproto::test::Response_BodyType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_test_2eproto__INCLUDED
